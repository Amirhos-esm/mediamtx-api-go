package mediamtx
// ai generated code
//somebody check this code and make sure it is correct :)
var DEFAULT_GLOBAL_CONF = GlobalConf{
	Api:                    ptr(false),
	ApiAddress:             ptr(":9997"),
	ApiAllowOrigin:         ptr("*"),
	ApiEncryption:          ptr(false),
	ApiServerCert:          ptr("server.crt"),
	ApiServerKey:           ptr("server.key"),
	ApiTrustedProxies:      &[]string{},
	AuthHTTPAddress:        ptr(""),
	AuthHTTPExclude:        &[]AuthInternalUserPermission{},
	AuthInternalUsers:      &[]AuthInternalUser{},
	AuthJWTJWKS:           ptr(""),
	AuthMethod:             ptr("internal"),
	Hls:                    ptr(true),
	HlsAddress:             ptr(":8888"),
	HlsAllowOrigin:         ptr("*"),
	HlsAlwaysRemux:         ptr(false),
	HlsDirectory:           ptr(""),
	HlsEncryption:          ptr(false),
	HlsMuxerCloseAfter:     ptr("60s"),
	HlsPartDuration:        ptr("200ms"),
	HlsSegmentCount:        ptr(7),
	HlsSegmentDuration:     ptr("1s"),
	HlsSegmentMaxSize:      ptr("50M"),
	HlsServerCert:          ptr("server.crt"),
	HlsServerKey:           ptr("server.key"),
	HlsTrustedProxies:      &[]string{},
	HlsVariant:             ptr("lowLatency"),
	LogDestinations:        &[]string{"stdout"},
	LogFile:                ptr("mediamtx.log"),
	LogLevel:               ptr("info"),
	Metrics:                ptr(false),
	MetricsAddress:         ptr(":9998"),
	MetricsAllowOrigin:     ptr("*"),
	MetricsEncryption:      ptr(false),
	MetricsServerCert:      ptr("server.crt"),
	MetricsServerKey:       ptr("server.key"),
	MetricsTrustedProxies:  &[]string{},
	MulticastIPRange:       ptr("224.1.0.0/16"),
	MulticastRTCPPort:      ptr(8003),
	MulticastRTPPort:       ptr(8002),
	Playback:               ptr(false),
	PlaybackAddress:        ptr(":9996"),
	PlaybackAllowOrigin:    ptr("*"),
	PlaybackEncryption:     ptr(false),
	PlaybackServerCert:     ptr("server.crt"),
	PlaybackServerKey:      ptr("server.key"),
	PlaybackTrustedProxies: &[]string{},
	Pprof:                  ptr(false),
	PprofAddress:           ptr(":9999"),
	PprofAllowOrigin:       ptr("*"),
	PprofEncryption:        ptr(false),
	PprofServerCert:        ptr("server.crt"),
	PprofServerKey:         ptr("server.key"),
	PprofTrustedProxies:    &[]string{},
	ReadTimeout:            ptr("10s"),
	RtcpAddress:            ptr(":8001"),
	Rtmp:                   ptr(true),
	RtmpAddress:            ptr(":1935"),
	RtmpEncryption:         ptr("no"),
	RtmpServerCert:         ptr("server.crt"),
	RtmpServerKey:          ptr("server.key"),
	RtmpsAddress:           ptr(":1936"),
	RtpAddress:             ptr(":8000"),
	Rtsp:                   ptr(true),
	RtspAddress:            ptr(":8554"),
	RtspAuthMethods:        &[]string{"basic"},
	RtspEncryption:         ptr("no"),
	RtspServerCert:         ptr("server.crt"),
	RtspServerKey:          ptr("server.key"),
	RtspTransports:         &[]string{"udp", "multicast", "tcp"},
	RtspsAddress:           ptr(":8322"),
	RunOnConnect:           ptr(""),
	RunOnConnectRestart:    ptr(false),
	RunOnDisconnect:        ptr(""),
	Srt:                    ptr(true),
	SrtAddress:             ptr(":8890"),
	UdpMaxPayloadSize:      ptr(1472),
	Webrtc:                 ptr(true),
	WebrtcAdditionalHosts:  &[]string{},
	WebrtcAddress:          ptr(":8889"),
	WebrtcAllowOrigin:      ptr("*"),
	WebrtcEncryption:       ptr(false),
	WebrtcHandshakeTimeout: ptr("10s"),
	WebrtcICEServers2:      &[]struct {
		ClientOnly *bool   `json:"clientOnly,omitempty"`
		Password   *string `json:"password,omitempty"`
		Url        *string `json:"url,omitempty"`
		Username   *string `json:"username,omitempty"`
	}{},
	WebrtcIPsFromInterfaces:     ptr(true),
	WebrtcIPsFromInterfacesList: &[]string{},
	WebrtcLocalTCPAddress:       ptr(""),
	WebrtcLocalUDPAddress:       ptr(":8189"),
	WebrtcServerCert:            ptr("server.crt"),
	WebrtcServerKey:             ptr("server.key"),
	WebrtcTrackGatherTimeout:    ptr("2s"),
	WebrtcTrustedProxies:        &[]string{},
	WriteQueueSize:              ptr(512),
	WriteTimeout:                ptr("10s"),
}

var DEFAULT_DEFAULT_PATH_CONF = PathConf{
	Fallback:                   ptr(""),
	MaxReaders:                 ptr(0),
	Name:                       ptr(""),
	OverridePublisher:          ptr(true),
	Record:                     ptr(false),
	RecordDeleteAfter:          ptr("24h"),
	RecordFormat:               ptr("fmp4"),
	RecordPartDuration:         ptr("1s"),
	RecordPath:                 ptr("./recordings/%path/%Y-%m-%d_%H-%M-%S-%f"),
	RecordSegmentDuration:      ptr("1h"),
	RpiCameraAWB:               ptr("auto"),
	RpiCameraAWBGains:          &[]float32{0, 0},
	RpiCameraAfMode:            ptr("continuous"),
	RpiCameraAfRange:           ptr("normal"),
	RpiCameraAfSpeed:           ptr("normal"),
	RpiCameraAfWindow:          ptr(""),
	RpiCameraBitrate:           ptr(1000000),
	RpiCameraBrightness:        ptr(float32(0)),
	RpiCameraCamID:             ptr(0),
	RpiCameraCodec:             ptr(""),
	RpiCameraContrast:          ptr(float32(1)),
	RpiCameraDenoise:           ptr("off"),
	RpiCameraEV:                ptr(float32(0)),
	RpiCameraExposure:          ptr("normal"),
	RpiCameraFPS:               ptr(float32(30)),
	RpiCameraFlickerPeriod:     ptr(0),
	RpiCameraGain:              ptr(float32(0)),
	RpiCameraHDR:               ptr(false),
	RpiCameraHFlip:             ptr(false),
	RpiCameraHeight:            ptr(1080),
	RpiCameraIDRPeriod:         ptr(60),
	RpiCameraLensPosition:      ptr(float32(0.0)),
	RpiCameraLevel:             ptr("4.1"),
	RpiCameraMetering:          ptr("centre"),
	RpiCameraMode:              ptr(""),
	RpiCameraProfile:           ptr("main"),
	RpiCameraROI:               ptr(""),
	RpiCameraSaturation:        ptr(float32(1)),
	RpiCameraSharpness:         ptr(float32(1)),
	RpiCameraShutter:           ptr(0),
	RpiCameraTextOverlay:       ptr("%Y-%m-%d %H:%M:%S - MediaMTX"),
	RpiCameraTextOverlayEnable: ptr(false),
	RpiCameraTuningFile:        ptr(""),
	RpiCameraVFlip:             ptr(false),
	RpiCameraWidth:             ptr(1920),
	RtspAnyPort:                ptr(false),
	RtspRangeStart:             ptr(""),
	RtspRangeType:              ptr(""),
	RtspTransport:              ptr("automatic"),
	RunOnDemand:                ptr(""),
	RunOnDemandCloseAfter:      ptr("10s"),
	RunOnDemandRestart:         ptr(false),
	RunOnDemandStartTimeout:    ptr("10s"),
	RunOnInit:                  ptr(""),
	RunOnInitRestart:           ptr(false),
	RunOnNotReady:              ptr(""),
	RunOnRead:                  ptr(""),
	RunOnReadRestart:           ptr(false),
	RunOnReady:                 ptr(""),
	RunOnReadyRestart:          ptr(false),
	RunOnRecordSegmentComplete: ptr(""),
	RunOnRecordSegmentCreate:   ptr(""),
	RunOnUnDemand:              ptr(""),
	RunOnUnread:                ptr(""),
	Source:                     ptr("publisher"),
	SourceFingerprint:          ptr(""),
	SourceOnDemand:             ptr(false),
	SourceOnDemandCloseAfter:   ptr("10s"),
	SourceOnDemandStartTimeout: ptr("10s"),
	SourceRedirect:             ptr(""),
	SrtPublishPassphrase:       ptr(""),
	SrtReadPassphrase:          ptr(""),
}

func ptr[T any](val T) *T {
	return &val
}